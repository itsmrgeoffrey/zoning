ZONING: Complete Transaction Flow
Starting Point: User Opens App

1. USER LOGS IN
User action:

Enters username + password
OR uses Face ID to authenticate

Backend receives:
javascript{
  username: "alice",
  password: "hashed_password"
  // OR biometric token
}

2. BACKEND VALIDATES CREDENTIALS
Authentication service checks:
javascriptuser = userDatabase.findByUsername("alice")
if (password matches) → authenticated ✓

3. BACKEND CHECKS FOR ZONE 1 REGISTRATION
Device registry lookup:
javascriptdevice = deviceRegistry.get(userId: "alice")
Two scenarios:
A. Device Already Registered (Returning User):
javascript{
  deviceId: "device-abc-123",
  userId: "alice",
  publicKey: "04a3f2b9...",
  zone1AssertionId: "assertion-xyz-789",
  registeredAt: 1703001234000
}
→ Skip to Step 5
B. New Device (First Time):
→ Continue to Step 4

4. NEW DEVICE REGISTRATION (Zone 1 Setup)
Backend triggers:
javascriptinitiateDeviceRegistration(userId: "alice")
Device generates keypair:
javascript{
  publicKey: "04a3f2b9...",   // Sent to backend
  privateKey: "secret..."      // STAYS ON DEVICE FOREVER
}
Device sends to backend:
javascript{
  userId: "alice",
  deviceId: "device-abc-123",  // Generated by device
  publicKey: "04a3f2b9..."
}
Backend stores:
javascriptdeviceRegistry.set("device-abc-123", {
  userId: "alice",
  deviceId: "device-abc-123",
  publicKey: "04a3f2b9...",
  registeredAt: Date.now()
})
Backend creates Zone 1 Assertion:
javascriptzone1Assertion = {
  zone: 1,
  assertionId: "assertion-xyz-789",
  userId: "alice",
  deviceId: "device-abc-123",
  issuedAt: Date.now()
}
Backend stores assertion:
javascriptassertionRegistry.set("assertion-xyz-789", zone1Assertion)
Backend sends to device:
javascript{
  zone1Assertion: {
    assertionId: "assertion-xyz-789",
    deviceId: "device-abc-123"
  }
}
Device stores locally:
javascriptlocalStorage.set("zone1AssertionId", "assertion-xyz-789")
localStorage.set("deviceId", "device-abc-123")
// Private key already in secure enclave

5. SESSION TOKEN ISSUED
Backend creates session:
javascriptsessionToken = generateJWT({
  userId: "alice",
  deviceId: "device-abc-123",
  expiresIn: "24h"
})
Backend sends to device:
javascript{
  success: true,
  sessionToken: "eyJhbGc...",
  user: {
    userId: "alice",
    name: "Alice Johnson",
    accountBalance: 5000
  }
}
Device stores:
javascriptsessionStorage.set("token", sessionToken)
```

---

### **6. USER BROWSES ACCOUNT**

**User sees:**
```
Welcome, Alice!
Balance: $5,000

[Send Money]
[Transaction History]
[Settings]
```

**Status:**
- ✅ Logged in (session active)
- ✅ Zone 1 established (device trusted)
- ❌ NO transactional authority yet

---

### **7. USER INITIATES TRANSACTION**

**User clicks "Send Money"**

**User fills form:**
```
Amount: $100
To: Bob's Account (123456789)
Bank: First Bank
Narration: "Lunch money"
User clicks "Continue"

8. DEVICE SENDS TRANSACTION REQUEST
Device sends to backend:
javascript{
  sessionToken: "eyJhbGc...",
  payload: {
    amount: 100,
    to: "123456789",
    toName: "Bob",
    bank: "first-bank",
    narration: "Lunch money"
  },
  deviceId: "device-abc-123",
  zone1AssertionId: "assertion-xyz-789"
}

9. BACKEND CREATES CHALLENGE (Zone 2 Begins)
Backend validates session:
javascriptif (!verifySessionToken(sessionToken)) → REJECT
Backend creates challenge:
javascriptchallenge = crypto.randomBytes(32).toString('hex')
// Result: "a3f29bc7d8e1..."

challengeData = {
  challenge: "a3f29bc7d8e1...",
  payload: {
    amount: 100,
    to: "123456789",
    toName: "Bob",
    bank: "first-bank",
    narration: "Lunch money"
  },
  deviceId: "device-abc-123",
  zone1AssertionId: "assertion-xyz-789",
  timestamp: Date.now(),
  expiresAt: Date.now() + 60000  // 60 seconds
}
Backend stores challenge:
javascriptchallengeStore.set("a3f29bc7d8e1...", {
  ...challengeData,
  status: "pending"
})
Backend sends to device:
javascript{
  challenge: "a3f29bc7d8e1...",
  payload: {
    amount: 100,
    to: "123456789",
    toName: "Bob",
    bank: "first-bank",
    narration: "Lunch money"
  },
  timestamp: 1703012345678,
  expiresAt: 1703012405678
}
```

---

### **10. DEVICE SHOWS CONFIRMATION SCREEN**

**User sees:**
```
═══════════════════════════
   CONFIRM TRANSACTION
═══════════════════════════

Amount:      $100.00
To:          Bob (123456789)
Bank:        First Bank
Narration:   Lunch money

───────────────────────────
   [Confirm with Face ID]
───────────────────────────

Expires in: 58 seconds
User CANNOT edit anything.
User can only APPROVE or CANCEL.

11. USER COMPLETES FACE ID
User puts face to camera.
Face ID succeeds.

12. DEVICE CREATES ATTEMPT RECEIPT (Zone 2)
Device computes transaction hash:
javascriptcanonicalPayload = JSON.stringify({
  amount: 100,
  bank: "first-bank",
  narration: "Lunch money",
  to: "123456789",
  toName: "Bob"
})

dataToHash = [
  canonicalPayload,
  "device-abc-123",           // deviceId
  "assertion-xyz-789",        // zone1AssertionId
  "a3f29bc7d8e1...",         // challenge
  "1703012345678"            // timestamp
].join("|")

txHash = SHA256(dataToHash)
// Result: "7c8f3e2a1b9d..."
Device signs txHash:
javascriptsignature = sign(txHash, privateKey)  // Uses Zone 1 private key
// Result: "d4e9a7c2f1b8..."
This signature = ATTEMPT RECEIPT

13. DEVICE SUBMITS TO BACKEND
Device sends:
javascript{
  payload: {
    amount: 100,
    to: "123456789",
    toName: "Bob",
    bank: "first-bank",
    narration: "Lunch money"
  },
  challenge: "a3f29bc7d8e1...",
  attemptReceipt: "d4e9a7c2f1b8...",  // The signature
  deviceId: "device-abc-123",
  zone1AssertionId: "assertion-xyz-789"
}

14. API GATEWAY RECEIVES REQUEST
Gateway extracts:
javascript{
  payload,
  challenge,
  attemptReceipt,
  deviceId,
  zone1AssertionId
}

15. API GATEWAY VALIDATES (First Checkpoint)
Check 1: Challenge exists?
javascriptchallengeData = challengeStore.get("a3f29bc7d8e1...")
if (!challengeData) → REJECT "Challenge not found"
Check 2: Challenge expired?
javascriptif (Date.now() > challengeData.expiresAt) {
  → REJECT "Challenge expired"
}
Check 3: Challenge already used?
javascriptif (challengeData.status !== "pending") {
  → REJECT "Challenge already consumed"
}
Check 4: Payload matches?
javascriptreceivedCanonical = canonicalize(payload)
expectedCanonical = canonicalize(challengeData.payload)

if (receivedCanonical !== expectedCanonical) {
  → REJECT "Payload tampering detected"
}
Check 5: Device and assertion match?
javascriptif (deviceId !== challengeData.deviceId) {
  → REJECT "Device mismatch"
}
if (zone1AssertionId !== challengeData.zone1AssertionId) {
  → REJECT "Assertion mismatch"
}
Check 6: Recompute txHash
javascriptexpectedTxHash = createTxHash(challengeData)
// Result: "7c8f3e2a1b9d..."
Check 7: Get device public key
javascriptdevice = deviceRegistry.get("device-abc-123")
publicKey = device.publicKey  // "04a3f2b9..."
Check 8: Verify signature
javascriptisValid = verifySignature(
  txHash: "7c8f3e2a1b9d...",
  signature: "d4e9a7c2f1b8...",
  publicKey: "04a3f2b9..."
)

if (!isValid) → REJECT "Invalid signature"
ALL CHECKS PASSED ✓

16. API GATEWAY BURNS CHALLENGE
Mark as consumed:
javascriptchallengeData.status = "consumed"
challengeData.consumedAt = Date.now()

challengeStore.set("a3f29bc7d8e1...", challengeData)
Challenge can NEVER be reused.

17. API GATEWAY CREATES AUTHORIZATION PROOF
javascriptauthProof = {
  validated: true,
  txHash: "7c8f3e2a1b9d...",
  deviceId: "device-abc-123",
  userId: "alice",
  challenge: "a3f29bc7d8e1...",
  validatedAt: Date.now(),
  proofId: "proof-def-456"
}
Store proof:
javascriptconsumedProofs.set("proof-def-456", authProof)

18. FORWARD TO CORE BANKING
Gateway sends:
javascript{
  transaction: payload,
  authProof: {
    validated: true,
    proofId: "proof-def-456",
    txHash: "7c8f3e2a1b9d...",
    userId: "alice"
  }
}

19. CORE BANKING VALIDATES (Second Checkpoint)
Check 1: Auth proof exists?
javascriptif (!authProof || !authProof.validated) {
  → REJECT "No authorization proof"
}
Check 2: Proof in registry?
javascriptstoredProof = consumedProofs.get("proof-def-456")
if (!storedProof) {
  → REJECT "Proof not found"
}
Check 3: Proof not already consumed?
javascriptif (storedProof.consumed) {
  → REJECT "Proof already used"
}
Check 4: Business logic checks
javascript// Check account balance
account = accountRegistry.get("alice")
if (account.balance < 100) {
  → REJECT "Insufficient funds"
}

// Check daily limits
if (account.dailySpent + 100 > account.dailyLimit) {
  → REJECT "Daily limit exceeded"
}

// Check fraud rules
if (fraudDetection.isSuspicious(transaction)) {
  → REJECT "Transaction flagged"
}
ALL CHECKS PASSED ✓

20. CORE BANKING MARKS PROOF AS PROCESSING
javascriptstoredProof.processing = true
storedProof.processingAt = Date.now()

consumedProofs.set("proof-def-456", storedProof)

21. CORE BANKING CREATES LEDGER WRITE REQUEST
javascriptledgerWriteRequest = {
  transaction: {
    amount: 100,
    from: "alice",
    to: "123456789",
    bank: "first-bank",
    narration: "Lunch money"
  },
  authProof: {
    validated: true,
    proofId: "proof-def-456",
    readyForLedger: true
  }
}

22. LEDGER RECEIVES WRITE REQUEST (Zone 3 - Final Checkpoint)
Check 1: Authorization proof present?
javascriptif (!authProof || !authProof.readyForLedger) {
  → LOG & REJECT "Ledger write rejected: No authorization proof"
}
Check 2: Proof exists in registry?
javascriptstoredProof = consumedProofs.get("proof-def-456")
if (!storedProof) {
  → LOG & REJECT "Proof not found"
}
Check 3: Proof marked as processing?
javascriptif (!storedProof.processing) {
  → LOG & REJECT "Proof not validated by Core Banking"
}
Check 4: Proof not already consumed by ledger?
javascriptif (storedProof.consumed) {
  → LOG & REJECT "Proof already consumed"
}
ALL CHECKS PASSED ✓

23. LEDGER WRITES TRANSACTION
Create ledger entry:
javascriptledgerEntry = {
  id: "txn-ghi-789",
  transaction: {
    amount: 100,
    from: "alice",
    to: "123456789",
    bank: "first-bank",
    narration: "Lunch money"
  },
  authProof: {
    proofId: "proof-def-456",
    deviceId: "device-abc-123",
    userId: "alice",
    txHash: "7c8f3e2a1b9d..."
  },
  timestamp: Date.now(),
  status: "completed"
}
Write to ledger:
javascriptledger.push(ledgerEntry)
// OR
database.transactions.insert(ledgerEntry)

24. LEDGER PERMANENTLY BURNS PROOF
javascriptstoredProof.consumed = true
storedProof.consumedAt = Date.now()
storedProof.ledgerEntryId = "txn-ghi-789"

consumedProofs.set("proof-def-456", storedProof)
This proof can NEVER be reused.

25. PREPARE EXTERNAL PAYMENT (NIBSS)
Core Banking formats NIBSS payload:
javascriptnibssPayload = {
  SessionID: generateSessionId(),
  SourceAccountNumber: "alice-account",
  DestinationBankCode: "011",  // First Bank
  DestinationAccountNumber: "123456789",
  Amount: 100.00,
  Narration: "Lunch money",
  TransactionReference: "txn-ghi-789"
}
Send to NIBSS:
javascriptnibssResponse = await nibss.transfer(nibssPayload)
NIBSS responds:
javascript{
  ResponseCode: "00",
  Message: "Successful",
  NIBSSReference: "NIBSS2024122712345"
}

26. UPDATE LEDGER WITH NIBSS REFERENCE
javascriptledger.update("txn-ghi-789", {
  nibssReference: "NIBSS2024122712345",
  nibssStatus: "completed",
  completedAt: Date.now()
})

27. UPDATE ACCOUNT BALANCES
javascript// Debit Alice
accountRegistry.update("alice", {
  balance: 4900,  // Was 5000, now 4900
  dailySpent: dailySpent + 100
})

// Credit is handled by receiving bank via NIBSS

28. SEND SUCCESS RESPONSE TO DEVICE
Backend sends:
javascript{
  success: true,
  transaction: {
    id: "txn-ghi-789",
    amount: 100,
    to: "Bob (123456789)",
    status: "completed",
    timestamp: 1703012400000,
    reference: "NIBSS2024122712345"
  },
  newBalance: 4900
}
```

---

### **29. DEVICE SHOWS CONFIRMATION**

**User sees:**
```
═══════════════════════════
   ✓ TRANSACTION COMPLETE
═══════════════════════════

Amount Sent:     $100.00
To:              Bob (123456789)
Bank:            First Bank
Reference:       txn-ghi-789

New Balance:     $4,900.00

[View Receipt]  [Done]
═══════════════════════════

30. BOB RECEIVES MONEY
Bob's bank (via NIBSS):
javascript// Receives credit notification from NIBSS
incomingTransfer = {
  amount: 100,
  from: "alice-account",
  narration: "Lunch money",
  reference: "NIBSS2024122712345"
}

// Credits Bob's account
bobAccount.balance += 100
```

**Bob sees:**
```
New Transaction
+$100 from Alice
"Lunch money"

COMPLETE ✓

SUMMARY OF ZONES:
Zone 1 (Device Identity):

Established at login
Device registered with public key
Zone 1 assertion issued

Zone 2 (Transaction Authorization):

Challenge created by backend
User confirms with biometric
Device signs with private key
Attempt receipt created

Zone 3 (Ledger Enforcement):

API Gateway validates
Core Banking validates
Ledger refuses write without proof
Proof permanently burned


Money moved. Audit trail complete. Attack surface minimized.
