/**
 * ZONING v1.0 — Zone 1 Demo
 * Purpose: Establish cryptographic device identity
 */

const crypto = require('crypto');

/**
 * DEVICE: Generate a device keypair
 * In production this happens inside Secure Enclave / Android Keystore
 */
function generateDeviceKeypair() {
  const { publicKey, privateKey } = crypto.generateKeyPairSync('ec', {
    namedCurve: 'prime256v1'
  });

  return { publicKey, privateKey };
}

/**
 * DEVICE: Create a device identity object
 */
function createDeviceIdentity(userId) {
  const { publicKey, privateKey } = generateDeviceKeypair();
  const deviceId = crypto.randomUUID();

  return {
    userId,
    deviceId,
    publicKey,
    privateKey
  };
}

/**
 * BACKEND: Register device and issue Zone 1 Assertion
 * NOTE:
 * - Zone 1 grants access ONLY
 * - It MUST NOT be treated as transactional authority
 */
function issueZone1Assertion(deviceIdentity) {
  return {
    zone: 1,
    userId: deviceIdentity.userId,
    deviceId: deviceIdentity.deviceId,
    issuedAt: Date.now()
  };
}

/**


 * ---------------------------------------------------
 * ZONING v1.0 — Zone 2 Demo
 * Purpose: Produce a single-use ATTEMPT RECEIPT
 *
 * IMPORTANT:
 * - This is NOT re-authentication
 * - This is NOT session validation
 * - This represents a one-time transaction attempt
 *   performed by a logged-in human
 * ---------------------------------------------------
 */

/**
 * Canonicalize transaction payload
 * Ensures the same payload always produces the same hash
 */
function canonicalizePayload(payload) {
  return JSON.stringify(payload, Object.keys(payload).sort());
}

/**
 * Create a transaction hash (txHash)
 * This represents EXACTLY the transaction being attempted
 */
function createTxHash({ payload, deviceId, zone1AssertionId, nonce }) {
  const canonicalPayload = canonicalizePayload(payload);

  const dataToHash = [
    canonicalPayload,
    deviceId,
    zone1AssertionId,
    nonce
  ].join('|');

  return crypto
    .createHash('sha256')
    .update(dataToHash)
    .digest('hex');
}

/**
 * DEVICE: Sign txHash to produce ATTEMPT RECEIPT
 *
 * CRITICAL INVARIANT:
 * - This signature MUST ONLY be produced immediately after
 *   a live, blocking user confirmation (PIN / biometric)
 *   at the final transaction confirmation step.
 *
 * - This signature is:
 *   ✔ single-use
 *   ✔ action-bound
 *   ✔ proof of ATTEMPT
 *
 * - It is NOT session authority
 * - It is NOT reusable
 */
function signTxHash(txHash, privateKey) {
  const signer = crypto.createSign('SHA256');
  signer.update(txHash);
  signer.end();

  return signer.sign(privateKey, 'hex');
}

/**
 * ---- DEMO FLOW ----
 */

// Example transaction Alice sees and confirms
const transactionPayload = {
  amount: 10,
  currency: 'USD',
  to: 'AliceFriendAccount'
};

// Values coming from Zone 1 (access already established)
const deviceId = 'device-123';
const zone1AssertionId = 'zone1-assertion-abc';

// One-time nonce to prevent replay
const nonce = crypto.randomUUID();

// Backend-prepared transaction fingerprint
const txHash = createTxHash({
  payload: transactionPayload,
  deviceId,
  zone1AssertionId,
  nonce
});

// Simulated device private key
const { privateKey } = crypto.generateKeyPairSync('ec', {
  namedCurve: 'prime256v1'
});

/**
 * USER ACTION:
 * - User completes Face ID / PIN
 * - Only NOW is signing permitted
 */
const attemptReceipt = signTxHash(txHash, privateKey);

console.log('txHash:', txHash);
console.log('attempt receipt (signature):', attemptReceipt);

// Backend receives:
// - payload
// - txHash
// - nonce
// - attemptReceipt
// - zone1AssertionId
//
// Backend MUST:
// - recompute txHash
// - verify signature
// - ensure single-use
// - burn receipt before execution

// NOTE:
// Production deployments SHOULD use a backend-issued challenge nonce
// to strictly enforce single-use attempt receipts and prevent replay.

